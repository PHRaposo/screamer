<html lang="en">
<head>
<title>Screamer</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Screamer">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
.node { visibility:hidden; height: 0px; }
  .menu { visibility:hidden; height: 0px; }
  .chapter { background-color:#e4bbff; padding: 0.2em; }
  .section { background-color:#e4bbff; padding: 0.2em; }
  .settitle { background-color:#e4bbff; }
  .contents { border: 2px solid black;
              margin: 1cm 1cm 1cm 1cm;
              padding-left: 3mm; }
  .lisp { padding: 0; margin: 0em; }
  body { padding: 2em 8em; font-family: sans-serif; }
  h1 { padding: 1em; text-align: center; }
  li { margin: 1em; }

--></style>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3652989-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  </script>
</head>
<body>
<h1 class="settitle">Screamer</h1>
Screamer provides a nondeterministic choice-point operator, a
backtracking mechanism, and a forward propagation facility.

   <p>Screamer was originally written by Jeffrey Mark Siskind and David
Allen McAllester.

   <p>The copy of Screamer this documentation refers to is maintained
courtesy of <a href="http://sb-studio.net/">Steel Bank Studio Ltd</a> by
<a href="mailto:nikodemus@sb-studio.net">Nikodemus Siivola</a>.

   <p>The Google Group
<pre class="example">     <a href="http://groups.google.com/group/screamer/">http://groups.google.com/group/screamer/</a>
</pre>
   <p>exists for Screamer-related discussions.

   <p>Screamer is maintained in Git:
<pre class="example">     git clone git://github.com/nikodemus/screamer.git
</pre>
   <p>will get you a local copy.
<pre class="example">     <a href="http://github.com/nikodemus/screamer">http://github.com/nikodemus/screamer</a>
</pre>
   <p>is the GitHub project page.

   <p>NOTE: This documentation is a work in progress. In the meanwhile you
may wish to refer to the original papers below.

   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_TOC0" href="#TOC0">1 Original Publications</a>
<li><a name="toc_TOC1" href="#TOC1">2 Overview</a>
<ul>
<li><a href="#TOC2">2.1 Important Note on Packages</a>
<li><a href="#TOC3">2.2 Choice-Points, Failure, and Backtracking</a>
<li><a href="#TOC4">2.3 Generators</a>
<li><a href="#TOC5">2.4 Side-Effects</a>
<li><a href="#TOC6">2.5 Constraints</a>
<li><a href="#TOC7">2.6 Current Limitations</a>
<ul>
<li><a href="#TOC8">2.6.1 Not Supported At All</a>
<li><a href="#TOC9">2.6.2 Limited Support</a>
</li></ul>
</li></ul>
<li><a name="toc_TOC10" href="#TOC10">3 Examples</a>
<ul>
<li><a href="#TOC11">3.1 Einstein's Riddle</a>
<li><a href="#TOC12">3.2 The Zebra Puzzle</a>
</li></ul>
<li><a name="toc_TOC13" href="#TOC13">4 Nondetermism</a>
<li><a name="toc_TOC14" href="#TOC14">5 Constraints</a>
<li><a name="toc_TOC15" href="#TOC15">6 Miscellany</a>
<li><a name="toc_TOC16" href="#TOC16">7 Examples</a>
<ul>
<li><a href="#TOC17">7.1 Einstein's Riddle</a>
</li></ul>
</li></ul>
</div>

<h2 class="chapter"><a name="TOC0"></a>1 Original Publications</h2>

<p>Following original publications by Siskind and McAllester form the
basis of this manual:

   <p><a href="http://nikodemus.github.com/screamer/screaming-yellow-zonkers.pdf">Screaming Yellow Zonkers</a>, 1991. Old Screamer manual, doesn't always
hold true for Screamer 3.20 on which this &ldquo;modern&rdquo; Screamer is
based, but still probably the most complete discussion of various
operators.

   <p><a href="http://nikodemus.github.com/screamer/screamer-paper.pdf">Screamer: A Portable Efficient Implementation of Nondeterministic Common Lisp</a>, 1993. A paper describing the fundamentals of Screamer.

   <p><a href="http://nikodemus.github.com/screamer/nondeterministic-lisp.pdf">Nondeterministic Lisp as a Substrate for Constraint Logic Programming</a>, 1993. A paper describing the constaints propagation
features of Screamer.

<h2 class="chapter"><a name="TOC1"></a>2 Overview</h2>

<h3 class="section"><a name="TOC2"></a>2.1 Important Note on Packages</h3>

<p>Screamer shadows <code>defun</code>.

   <p>Examples in this manual are expected to be entered in the package
<code>SCREAMER-USER</code>, which has the correct <code>defun</code>.

   <p>Packages using Screamer are best defined using
<code>define-screamer-package</code>, which is like <code>defpackage</code> but
does some additional shadowing imports.

   <p>This is however by no means necessary: you can also explicitly use
<code>screamer::defun</code>.

<h3 class="section"><a name="TOC3"></a>2.2 Choice-Points, Failure, and Backtracking</h3>

<p>Screamer adds nondeterminism by providing the <em>choice-point</em>
operator <code>either</code> and the <em>failure</em> operator <code>fail</code>.

   <p>A choice-point is a point in program where more than one thing can
happen. When a choice point is encountered, one of the possibilities
occurs, and execution continues. Should a failure subsequently occur,
the system backtracks to the last choice-point where multiple
possibilities were still present, and tries again.

<pre class="lisp">     (all-values
       (let ((x (either 1 2 3 4)))
         (if (oddp x)
             x
             (fail)))) ; =&gt; (1 3)
</pre>
   <p>At first <code>(either 1 2 3 4)</code> evaluates to 1, which is <code>oddp</code>,
so <code>all-values</code> receives it and sets about producing the next
value.

   <p>This time <code>either</code> returns 2, which isn't <code>oddp</code>. Hence
<code>fail</code> is called causing the system to backtrack.

   <p>Starting again from the choice-point 3 is produced, which is
<code>oddp</code>, and is received by <code>all-values</code>, which in turn
requests the next value.

   <p>Now <code>either</code> returns 4, which again causes <code>fail</code> to backtrack.

   <p>Since the only choice-point available cannot produce any more alternatives,
control passes back to <code>all-values</code> which returns the collected values.

   <p>Had we wanted only one answer instead of an enumeration of all
possible answers we could have used <code>one-value</code> instead of
<code>all-values</code>.

   <p>If you're familiar with Prolog, <code>all-values</code> and <code>one-value</code>
are analogous to Prolog's <code>bag-of</code> and <code>cut</code> primitives.

<h3 class="section"><a name="TOC4"></a>2.3 Generators</h3>

<p>Given <code>either</code> and <code>fail</code> we can write functions returning
arbitrary sequences of nondeterministic values. Such functions are
called <em>generators</em>, and by convention have names starting with
<code>a-</code> or <code>an-</code>.

   <p>Consider for example <code>an-integer-between</code>:

<pre class="lisp">     ;;; Screamer already provides an-integer-between, so we'll
     ;;; call this by a different name.
     (defun an-int-between (min max)
       (if (&gt; min max)
           (fail)
           (either min (an-int-between (1+ min) max))))
     
     (all-values (an-int-between 41 43)) ; =&gt; (41 42 43)
</pre>
   <p>Called with two integers, this function produces nondeterministic
values in the given range &ndash; finally backtracking to a previous
choice-point when possibilities have already been exhausted.

   <p>Given <code>an-integer-between</code> and <code>fail</code> we can write eg. a
generator for square numbers:

<pre class="lisp">     ;;; Square numbers are numbers produced by multiplying an integer with itself.
     (defun a-square-number (min max)
       (let* ((x (an-integer-between 0 max))
              (square (* x x)))
         (if (&lt;= min square max)
             square
             (fail))))
     
     (all-values (a-square-number 12 80)) ; =&gt; (16 25 36 49 64)
</pre>
   <p>We're not restricted to numbers, of course. Writing a generator for
potential comedy duos works just the same:

<pre class="lisp">     (defun a-comedic-actor ()
       (list (either :tall :short) (either :thin :fat)))
     
     (defun a-comedy-duo ()
       (let ((a (a-comedic-actor))
             (b (a-comedic-actor)))
         (if (or (eq (first a) (first b))
                 (eq (second a) (second b)))
             (fail)
             (list a :and b))))
     
     (one-value (a-comedy-duo)) ; =&gt; ((:TALL :THIN) :AND (:SHORT :FAT))
</pre>
   <h3 class="section"><a name="TOC5"></a>2.4 Side-Effects</h3>

<p>What should happen to side-effects when a nondeterministic function
backtracks? It depends. Some side-effects should be retained, and
some undone &ndash; and it is impossible for the system to know in
general what is the right choice in a given case.

   <p>Screamer is able to undo effects of <code>setf</code> and <code>setq</code>
(including calls to user-defined setf-functions), but cannot undo
calls to other functions with side-effects such as <code>set</code>,
<code>rplaca</code>, or <code>sort</code>.

   <p>By default most side-effects are retained:

<pre class="lisp">     (let ((n 0))
       (list :numbers
             (all-values (let ((x (an-integer-between 0 3)))
                           (incf n)
                           x))
             :n n)) ; =&gt; (:NUMBERS (0 1 2 3) :N 4)
</pre>
   <p>Macros <code>local</code> and <code>global</code> can be used to turn undoing of
side-effects on and off lexically.

<pre class="lisp">     (let ((m 0)
           (n 0))
       (list :numbers
             (all-values (let ((x (an-integer-between 0 3)))
                           (local
                             (incf n)
                             (global
                               (incf m)))
                           x))
             :m m
             :n n)) ; =&gt; (:NUMBERS (0 1 2 3) :M 4 :N 0)
</pre>
   <h3 class="section"><a name="TOC6"></a>2.5 Constraints</h3>

<p>In addition to nondeterminism via backtracking as discussed so far,
Screamer also provides for forward constraint propagation via
<em>logic variables</em> constructed using <code>make-variable</code>. 
Screamer provides a variety of primitives for constraining variables.

   <p>By convention suffix <code>v</code> is used to denote operators that accept
(and potentially return) variables in addition to values. Any
<code>foov</code> is generally just like <code>foo</code>, except its arguments
can also be logic variables, and that it may assert facts about them
and will possibly return another variable.

   <p>The operator <code>assert!</code> is the primary tool about asserting facts
about variables.

   <p>Expression such as <code>(foov myvar)</code> typically returns another
variable depending on <code>myvar</code>, which can be constrained to be
true using <code>assert!</code>.

<pre class="lisp">     ;;; Make a variable
     (defparameter *v* (make-variable "The Answer"))
     
     ;;; It is initially unconstrained.
     *v* ; =&gt; ["The Answer"]
     
     ;;; Constrain it to be an integer.
     (assert! (integerpv *v*))
     
     *v* ; =&gt; ["The Answer" integer]
     
     ;;; Constrain 40 to be 2 less than *v*
     (assert! (=v 40 (-v *v* 2)))
     
     ;;; And we have our answer.
     *v* ; =&gt; 42
</pre>
   <p>Assertions &ndash; and constraint operators in general &ndash; can cause failure
and backtracking, in which case constraints from the last attempt are
undone.

   <p>This allows us to search the solution space using backtracking:

<pre class="lisp">     (defparameter *x* (make-variable "X"))
     (defparameter *y* (make-variable "Y"))
     
     (assert! (integerpv *x*))
     (assert! (integerpv *y*))
     
     (assert! (=v 0 (+v *x* *y* 42)))
     
     (all-values (let ((x (an-integer-between -50 -30))
                       (y (an-integer-between 2 5)))
                   (assert! (=v *x* x))
                   (assert! (=v *y* y))
                   (list x y))) ; =&gt; ((-47 5) (-46 4) (-45 3) (-44 2))
</pre>
   <p>A possibly less intuitive, but usually more efficient method is to
assert range constraints as variables instead of nondeterministic
values, and force a solution:

<pre class="lisp">     (all-values
       (assert! (=v *x* (an-integer-betweenv -50 -30)))
       (assert! (=v *y* (an-integer-betweenv 2 5)))
       (solution (list *x* *y*)
                 (static-ordering #'linear-force))) =&gt; ((-47 5) (-46 4) (-45 3) (-44 2))
</pre>
   <p>In this case backtracking occurs only over <code>solution</code>, whereas in the first
one we backtracked over the entire <code>let</code>.

<h3 class="section"><a name="TOC7"></a>2.6 Current Limitations</h3>

<p>Screamer is implemented using a code-walker, which does not
unfortunately currently support the full ANSI Common Lisp.

<h4 class="subsection"><a name="TOC8"></a>2.6.1 Not Supported At All</h4>

<p>Following special operators signal an error if they appear in code processed
by the code walker:

     <ul>
<li>load-time-value
<li>symbol-macrolet
<li>macrolet

   </ul>

<h4 class="subsection"><a name="TOC9"></a>2.6.2 Limited Support</h4>

<p>Following special operators are accepted, but they cannot contain
nondeterministic forms:

     <ul>
<li>progv
<li>unwind-protect
<li>catch

   </ul>

   <p>Additionally, functions defined using <code>flet</code> and <code>labels</code>
are not in nondeterministic context, even if the surrounding context
is nondeterministic.

<h2 class="chapter"><a name="TOC10"></a>3 Examples</h2>

<h3 class="section"><a name="TOC11"></a>3.1 Einstein's Riddle</h3>

<p>Solving the &ldquo;Einstein's Riddle&rdquo; using nondeterministic features of
Screamer, ie. backtracking search.

   <p>[ <a href="einstein.lisp.html">HTML</a> ]
[ <a href="einstein.lisp">Source</a> ]

<h3 class="section"><a name="TOC12"></a>3.2 The Zebra Puzzle</h3>

<p>Solving the &ldquo;The Zebra Puzzle&rdquo;, using forward constraint propagation
features of Screamer.

   <p>(This puzzle is virtually identical to &ldquo;Einstein's Riddle&rdquo;, but the
solution is very different.)

   <p>[ <a href="zebra.lisp.html">HTML</a> ]
[ <a href="zebra.lisp">Source</a> ]

<h2 class="chapter"><a name="TOC13"></a>4 Nondetermism</h2>

<p><a name="Macro-either"></a>

<div class="defun">
&mdash; Macro: <b>either</b><var> &amp;body expressions<a name="index-either-1"></a></var><br>
<blockquote><p><a name="index-either-2"></a>Nondeterministically evaluates and returns the value of one of its
<code>expressions</code>.

        <p><code>either</code> takes any number of arguments. With no arguments, <code>(either) </code>is
equivalent to <code>(fail) </code>and is thus deterministic. With one argument,
<code>(either expression) </code>is equivalent to expression itself and is thus deterministic
only when <code>expression</code> is deterministic. With two or more argument it is
nondeterministic and can only appear in a nondeterministic context.

        <p>It sets up a choice point and evaluates the first <code>expression</code> returning its
result. Whenever backtracking proceeds to this choice point, the next
<code>expression</code> is evaluated and its result returned. When no more <code>expressions</code>
remain, the current choice point is removed and backtracking continues to the
next most recent choice point.

        <p>As an optimization, the choice point created for this expression is removed
before the evaluation of the last <code>expression</code> so that a failure during the
evaluation of the last expression will backtrack directly to the parent choice
point of the <code>either</code> expression.

        <p><code>either</code> is a special form, not a function. It is an error for the expression
<code>#'either</code> to appear in a program. 
</p></blockquote></div>

   <p><a name="Function-fail"></a>

<div class="defun">
&mdash; Function: <b>fail</b><var><a name="index-fail-3"></a></var><br>
<blockquote><p><a name="index-fail-4"></a>Backtracks to the most recent choise point. Equivalent to
<code>(either)</code>. Note that <code>fail</code> is deterministic function and thus it is
permissible to reference <code>#'fail</code>, and write <code>(funcall #'fail) </code>or
<code>(apply #'fail)</code>. In nondeterministic contexts, the expression <code>(fail)</code>
is optimized to generate inline backtracking code. 
</p></blockquote></div>

   <p><a name="Macro-all_002dvalues"></a>

<div class="defun">
&mdash; Macro: <b>all-values</b><var> &amp;body expressions<a name="index-all_002dvalues-5"></a></var><br>
<blockquote><p><a name="index-all_002dvalues-6"></a>Evaluates <code>expressions</code> as an implicit <code>progn</code> and returns a list of all of the
nondeterministic values returned by the last <code>expression</code>.

        <p>These values are produced by repeatedly evaluating the body and backtracking
to produce the next value, until the body fails and yields no further values.

        <p>Accordingly, local side effects performed by the body while producing each
value are undone before attempting to produce subsequent values, and all local
side effects performed by the body are undone upon exit from <code>all-values</code>.

        <p>Returns the list containing <code>nil</code> if there are no <code>expressions</code>. An <code>all-values</code>
expression can appear in both deterministic and nondeterministic contexts. 
Irrespective of what context the <code>all-values</code> expression appears in, the
<code>expressions</code> are always in a nondeterministic context. An <code>all-values</code> expression
itself is always deterministic. <code>all-values</code> is analogous to the bagof primitive
in Prolog. 
</p></blockquote></div>

   <p><a name="Macro-one_002dvalue"></a>

<div class="defun">
&mdash; Macro: <b>one-value</b><var> expression &amp;optional default-expression<a name="index-one_002dvalue-7"></a></var><br>
<blockquote><p><a name="index-one_002dvalue-8"></a>Returns the first value of a nondeterministic expression. <code>expression</code> is
evaluated, deterministically returning only its first nondeterministic value,
if any.

        <p>No further execution of <code>expression</code> is attempted after it successfully returns
one value.

        <p>If <code>expression</code> does not return any nondeterministic values (i.e. it fails)
then <code>default-expression</code> is evaluated and its value returned instead. 
<code>default-expression</code> defaults to <code>(fail) </code>if not present.

        <p>Local side effects performed by <code>expression</code> are undone when <code>one-value</code> returns,
but local side effects performed by <code>default-expression</code> are not undone when
<code>one-value</code> returns.

        <p>A <code>one-value</code> expression can appear in both deterministic and nondeterministic
contexts. Irrespective of what context the <code>one-value</code> expression appears in,
<code>expression</code> is always in a nondeterministic context, while <code>default-expression</code>
is in whatever context the <code>one-value</code> expression appears.

        <p>A <code>one-value</code> expression is nondeterministic if <code>default-expression</code> is present
and is nondeterministic, otherwise it is deterministic.

        <p>If <code>default-expression</code> is present and nondeterministic, and if <code>expression</code>
fails, then it is possible to backtrack into the <code>default-expression</code> and for
the <code>one-value</code> expression to nondeterministically return multiple times. 
<code>one-value</code> is analogous to the cut primitive <code>(!) </code>in Prolog. 
</p></blockquote></div>

   <p><a name="Macro-for_002deffects"></a>

<div class="defun">
&mdash; Macro: <b>for-effects</b><var> &amp;body forms<a name="index-for_002deffects-9"></a></var><br>
<blockquote><p><a name="index-for_002deffects-10"></a>Evaluates <code>forms</code> as an implicit <code>progn</code> in a nondeterministic context and
returns <code>nil</code>.

        <p>The body is repeatedly backtracked to its first choice-point until the body
fails.

        <p>Local side effects performed by <code>forms</code> are undone when <code>for-effects</code> returns.

        <p>A <code>for-effects</code> expression can appear in both deterministic and nondeterministic
contexts. Irrespective of what context the <code>for-effects</code> expression appears in,
<code>forms</code> are always in a nondeterministic context.

        <p>A <code>for-effects</code> expression is is always deterministic. 
</p></blockquote></div>

   <p><a name="Macro-ith_002dvalue"></a>

<div class="defun">
&mdash; Macro: <b>ith-value</b><var> i expression &amp;optional default-expression<a name="index-ith_002dvalue-11"></a></var><br>
<blockquote><p><a name="index-ith_002dvalue-12"></a>Returns the Ith value of a nondeterministic expression. <code>expression</code> is
evaluated, deterministically returning only its Ith nondeterministic value, if
any. I must be an integer. The first nondeterministic value returned by
<code>expression</code> is numbered zero, the second one, etc. The Ith value is produced by
repeatedly evaluating <code>expression</code>, backtracking through and discarding the
first I values and deterministically returning the next value produced.

        <p>No further execution of <code>expression</code> is attempted after it successfully returns
the desired value.

        <p>If <code>expression</code> fails before returning both the I values to be discarded, as
well as the desired Ith value, then <code>default-expression</code> is evaluated and its
value returned instead. <code>default-expression</code> defaults to <code>(fail) </code>if not present.

        <p>Local side effects performed by <code>expression</code> are undone when <code>ith-value</code> returns,
but local side effects performed by <code>default-expression</code> and by I are not undone
when <code>ith-value</code> returns.

        <p>An <code>ith-value</code> expression can appear in both deterministic and nondeterministic
contexts. Irrespective of what context the <code>ith-value</code> expression appears in,
<code>expression</code> is always in a nondeterministic context, while <code>default-expression</code>
and I are in whatever context the <code>ith-value</code> expression appears.

        <p>An <code>ith-value</code> expression is nondeterministic if <code>default-expression</code> is present
and is nondeterministic, or if I is nondeterministic. Otherwise it is
deterministic.

        <p>If <code>default-expression</code> is present and nondeterministic, and if <code>expression</code>
fails, then it is possible to backtrack into the <code>default-expression</code> and for
the <code>ith-value</code> expression to nondeterministically return multiple times.

        <p>If I is nondeterministic then the <code>ith-value</code> expression operates
nondeterministically on each value of I. In this case, backtracking for each
value of <code>expression</code> and <code>default-expression</code> is nested in, and restarted for,
each backtrack of I. 
</p></blockquote></div>

   <p><a name="Macro-print_002dvalues"></a>

<div class="defun">
&mdash; Macro: <b>print-values</b><var> &amp;body expressions<a name="index-print_002dvalues-13"></a></var><br>
<blockquote><p><a name="index-print_002dvalues-14"></a>Evaluates <code>expressions</code> as an implicit <code>progn</code> and prints
each of the nondeterministic values returned by the last <code>expression</code> in
succession using <code>print</code>.

        <p>After each value is printed, the user is queried as to whether or not further
values are desired. These values are produced by repeatedly evaluating the
body and backtracking to produce the next value, until either the user
indicates that no further values are desired or until the body fails and
yields no further values.

        <p>Accordingly, local side effects performed by the body while producing each
value are undone after printing each value, before attempting to produce
subsequent values, and all local side effects performed by the body are undone
upon exit from <code>print-values</code>, either because there are no further values or
because the user declines to produce further values.

        <p>A <code>print-values</code> expression can appear in both deterministic and
nondeterministic contexts. Irrespective of what context the <code>print-values</code>
expression appears in, the <code>expressions</code> are always in a nondeterministic
context. A <code>print-values</code> expression itself is always deterministic and always
returns <code>nil</code>.

        <p><code>print-values</code> is analogous to the standard top-level user interface in Prolog. 
</p></blockquote></div>

   <p><a name="Macro-possibly_003f"></a>

<div class="defun">
&mdash; Macro: <b>possibly?</b><var> &amp;body forms<a name="index-possibly_003f-15"></a></var><br>
<blockquote><p><a name="index-possibly_003f-16"></a>Evaluates <code>forms</code> as an implicit <code>progn</code> in nondeterministic context,
returning true if the body ever yields true.

        <p>The body is repeatedly backtracked as long as it yields <code>nil</code>. Returns
the first true value yielded by the body, or <code>nil</code> if body fails before
yielding true.

        <p>Local side effects performed by the body are undone when <code>possibly</code>? returns.

        <p>A <code>possibly</code>? expression can appear in both deterministic and nondeterministic
contexts. Irrespective of what context the <code>possibly</code>? expression appears in,
its body is always in a nondeterministic context.

        <p>A <code>possibly</code>? expression is always deterministic. 
</p></blockquote></div>

   <p><a name="Macro-necessarily_003f"></a>

<div class="defun">
&mdash; Macro: <b>necessarily?</b><var> &amp;body forms<a name="index-necessarily_003f-17"></a></var><br>
<blockquote><p><a name="index-necessarily_003f-18"></a>Evaluates <code>forms</code> as an implicit <code>progn</code> in nondeterministic context,
returning true if the body never yields false.

        <p>The body is repeatedly backtracked as long as it yields true. Returns the last
true value yielded by the body if it fails before yielding <code>nil</code>, otherwise
returns <code>nil</code>.

        <p>Local side effects performed by the body are undone when <code>necessarily</code>? returns.

        <p>A <code>necessarily</code>? expression can appear in both deterministic and
nondeterministic contexts. Irrespective of what context the <code>necessarily</code>? 
expression appears in, its body is always in a nondeterministic context.

        <p>A <code>necessarily</code>? expression is always deterministic. 
</p></blockquote></div>

   <p><a name="Macro-global"></a>

<div class="defun">
&mdash; Macro: <b>global</b><var> &amp;body expressions<a name="index-global-19"></a></var><br>
<blockquote><p><a name="index-global-20"></a>Evaluates <code>expressions</code> in the same fashion as <code>progn</code> except that all <code>setf</code> and
<code>setq</code> expressions lexically nested in its body result in global side effects
which are not undone upon backtracking.

        <p>Note that this affects only side effects introduced explicitly via <code>setf</code> and
<code>setq</code>. Side effects introduced by Common Lisp builtin functions such as <code>rplaca</code>
are always global anyway.

        <p>Furthermore, it affects only occurrences of <code>setf</code> and <code>setq</code> which appear
textually nested in the body of the <code>global</code> expression <code>--</code> not those appearing
in functions called from the body.

        <p><code>local</code> and <code>global</code> expressions may be nested inside one another. The nearest
surrounding declaration determines whether or not a given <code>setf</code> or <code>setq</code> results
in a local or global side effect.

        <p>Side effects default to be global when there is no surrounding <code>local</code> or <code>global</code>
expression. Global side effects can appear both in deterministic as well as
nondeterministic contexts. In nondeterministic contexts, <code>global</code> as well as
<code>setf</code> are treated as special forms rather than macros. This should be
completely transparent to the user. 
</p></blockquote></div>

   <p><a name="Macro-local"></a>

<div class="defun">
&mdash; Macro: <b>local</b><var> &amp;body expressions<a name="index-local-21"></a></var><br>
<blockquote><p><a name="index-local-22"></a>Evaluates <code>expressions</code> in the same fashion as <code>progn</code> except that all
<code>setf</code> and <code>setq</code> expressions lexically nested in its body result in local
side effects which are undone upon backtracking.

        <p>Note that this affects only side effects introduced explicitly via <code>setf</code> and
<code>setq</code>. Side effects introduced by Common Lisp builtin in functions such as
<code>rplaca</code> are always global.

        <p>Furthermore, it affects only occurrences of <code>setf</code> and <code>setq</code> which appear
textually nested in the body of the <code>local</code> expression <code>--</code> not those appearing in
functions called from the body.

        <p><code>local</code> and <code>global</code> expressions may be nested inside one another. The nearest
surrounding declaration determines whether or not a given <code>setf</code> or <code>setq</code> results
in a local or global side effect.

        <p>Side effects default to be global when there is no surrounding <code>local</code> or <code>global</code>
expression. Local side effects can appear both in deterministic as well as
nondeterministic contexts though different techniques are used to implement
the trailing of prior values for restoration upon backtracking. In
nondeterministic contexts, <code>local</code> as well as <code>setf</code> are treated as special forms
rather than macros. This should be completely transparent to the user. 
</p></blockquote></div>

   <p><a name="Function-a_002dboolean"></a>

<div class="defun">
&mdash; Function: <b>a-boolean</b><var><a name="index-a_002dboolean-23"></a></var><br>
<blockquote><p><a name="index-a_002dboolean-24"></a>Equivalent to <code>(either t nil)</code>. 
</p></blockquote></div>

   <p><a name="Function-a_002dmember_002dof"></a>

<div class="defun">
&mdash; Function: <b>a-member-of</b><var> sequence<a name="index-a_002dmember_002dof-25"></a></var><br>
<blockquote><p><a name="index-a_002dmember_002dof-26"></a>Nondeterministically returns an element of <code>sequence</code>. The elements are
returned in the order that they appear in <code>sequence</code>. The <code>sequence</code> must be
either a list or a vector. 
</p></blockquote></div>

   <p><a name="Function-an_002dinteger"></a>

<div class="defun">
&mdash; Function: <b>an-integer</b><var><a name="index-an_002dinteger-27"></a></var><br>
<blockquote><p><a name="index-an_002dinteger-28"></a>Generator yielding integers in sequence <code>0</code>, <code>1</code>, <code>-1</code>, <code>2</code>, <code>-2</code>, ... 
</p></blockquote></div>

   <p><a name="Function-an_002dinteger_002dabove"></a>

<div class="defun">
&mdash; Function: <b>an-integer-above</b><var> low<a name="index-an_002dinteger_002dabove-29"></a></var><br>
<blockquote><p><a name="index-an_002dinteger_002dabove-30"></a>Generator yielding integers starting from <code>low</code> and continuing sequentially
in increasing direction. 
</p></blockquote></div>

   <p><a name="Function-an_002dinteger_002dbelow"></a>

<div class="defun">
&mdash; Function: <b>an-integer-below</b><var> high<a name="index-an_002dinteger_002dbelow-31"></a></var><br>
<blockquote><p><a name="index-an_002dinteger_002dbelow-32"></a>Generator yielding integers starting from <code>high</code> and continuing sequentially
in decreasing direction. 
</p></blockquote></div>

   <p><a name="Function-an_002dinteger_002dbetween"></a>

<div class="defun">
&mdash; Function: <b>an-integer-between</b><var> low high<a name="index-an_002dinteger_002dbetween-33"></a></var><br>
<blockquote><p><a name="index-an_002dinteger_002dbetween-34"></a>Nondeterministically returns an integer in the closed interval [<code>low</code>, <code>high</code>]. 
The results are returned in ascending order. Both <code>low</code> and <code>high</code> must be
integers. Fails if the interval does not contain any integers. 
</p></blockquote></div>

   <p><a name="Function-apply_002dnondeterministic"></a>

<div class="defun">
&mdash; Function: <b>apply-nondeterministic</b><var> function &amp;rest arguments<a name="index-apply_002dnondeterministic-35"></a></var><br>
<blockquote><p><a name="index-apply_002dnondeterministic-36"></a>Analogous to the <code>cl:apply</code>, except <code>function</code> can be either a nondeterministic
function, or an ordinary deterministic function.

        <p>You must use <code>apply-nondeterministic</code> to apply a nondeterministic function. An
error is signalled if a nondeterministic function object is used with
<code>cl:apply</code>.

        <p>You can use <code>apply-nondeterministic</code> to apply either a deterministic or
nondeterministic function, though even if all of the <code>arguments</code> are
deterministic and <code>function</code> is a deterministic function object, the call
expression will still be nondeterministic (with presumably a single value),
since it is impossible to determine at compile time that a given call to
<code>apply-nondeterministic</code> will be passed only deterministic function objects for
function. 
</p></blockquote></div>

   <p><a name="Function-funcall_002dnondeterministic"></a>

<div class="defun">
&mdash; Function: <b>funcall-nondeterministic</b><var> function &amp;rest arguments<a name="index-funcall_002dnondeterministic-37"></a></var><br>
<blockquote><p><a name="index-funcall_002dnondeterministic-38"></a>Analogous to <code>cl:funcall</code>, except <code>function</code> can be either a nondeterministic
function, or an ordinary determinisitic function.

        <p>You must use <code>funcall-nondeterministic</code> to funcall a nondeterministic function. 
An error is signalled if you attempt to funcall a nondeterministic
function object with <code>cl:funcall</code>.

        <p>You can use <code>funcall-nondeterministic</code> to funcall either a deterministic or
nondeterministic function, though even if all of the <code>arguments</code> are
deterministic and <code>function</code> is a deterministic function object, the call
expression will still be nondeterministic (with presumably a single value),
since it is impossible to determine at compile time that a given call to
<code>funcall-nondeterministic</code> will be passed only deterministic function objects
for function. 
</p></blockquote></div>

   <p><a name="Function-multiple_002dvalue_002dcall_002dnondeterministic"></a>

<div class="defun">
&mdash; Function: <b>multiple-value-call-nondeterministic</b><var> function-form &amp;rest values-forms<a name="index-multiple_002dvalue_002dcall_002dnondeterministic-39"></a></var><br>
<blockquote><p><a name="index-multiple_002dvalue_002dcall_002dnondeterministic-40"></a>Analogous to the <code>cl:multiple-value-call</code>, except <code>function-form</code> can evaluate
to either a nondeterministic function, or an ordinary deterministic function.

        <p>You must use <code>multiple-value-call-nondeterministic</code> to multiple-value-call a
nondeterministic function. An error is signalled if a nondeterministic function
object is used with <code>cl:multiple-value-call</code>.

        <p>You can use <code>multiple-value-call-nondeterministic</code> to call either a
deterministic or nondeterministic function, though even if all of the
<code>values-forms</code> are deterministic and <code>function-form</code> evaluates to a deterministic
function object, the call expression will still be nondeterministic (with
presumably a single value), since it is impossible to determine at compile
time that a given call to <code>multiple-value-call-nondeterministic</code> will be passed
only deterministic function objects for function.

        <p>While <code>multiple-value-call-nondeterministic</code> appears to be a function, it
is really a special-operator implemented by the code-walkers processing
nondeterministic source contexts. 
</p></blockquote></div>

   <p><a name="Function-nondeterministic_002dfunction_003f"></a>

<div class="defun">
&mdash; Function: <b>nondeterministic-function?</b><var> x<a name="index-nondeterministic_002dfunction_003f-41"></a></var><br>
<blockquote><p><a name="index-nondeterministic_002dfunction_003f-42"></a>Returns <code>t</code> if <code>x</code> is a nondeterministic function and <code>nil</code> otherwise.

        <p><code>#'foo</code> returns a nondeterministic function object iff it is used in nondeterminisitc
context and <code>foo</code> is either a nondeterministic <code>lambda</code> form, or the name of a
nondeterministic function defined using <code>screamer::defun</code>.

        <p>Currently, if <code>foo</code> is a nondeterministic function defined using
<code>screamer::defun</code>, <code>#'foo</code> and <code>(symbol-function 'foo) </code>in deterministic context
will return an ordinary deterministic Common Lisp function, which will signal
an error at runtime. 
</p></blockquote></div>

<h2 class="chapter"><a name="TOC14"></a>5 Constraints</h2>

<p><a name="Function-booleanpv"></a>

<div class="defun">
&mdash; Function: <b>booleanpv</b><var> x<a name="index-booleanpv-43"></a></var><br>
<blockquote><p><a name="index-booleanpv-44"></a>The expression <code>(booleanpv x) </code>is an abbreviation for <code>(memberv x '(t nil))</code>. 
</p></blockquote></div>

   <p><a name="Function-_003dv"></a>

<div class="defun">
&mdash; Function: <b>=v</b><var> x &amp;rest xs<a name="index-g_t_003dv-45"></a></var><br>
<blockquote><p><a name="index-g_t_003dv-46"></a>Returns a boolean value which is constrained to be <code>t</code> if all of the
arguments are numerically equal, and constrained to be <code>nil</code> if two or more of
the arguments numerically differ.

        <p>This function takes one or more arguments. All of the arguments are restricted
to be numeric.

        <p>Returns <code>t</code> when called with one argument. A call such as <code>(=v x1 x2 ... xn)</code>
with more than two arguments behaves like a conjunction of two argument calls:

     <pre class="lisp">          
            (ANDV (=V X1 X2) ... (=V Xi Xi+1) ... (=V Xn-1 Xn))
     </pre>
        <p>When called with two arguments, returns <code>t</code> if <code>x1</code> is known to be equal to <code>x2</code> at
the time of call, <code>nil</code> if <code>x1</code> is known not to be equal to <code>x2</code> at the time of
call, and a new boolean variable <code>v</code> if is not known if the two values are
equal.

        <p>Two numeric values are known to be equal only when they are both bound and
equal according to the Common Lisp function <code>=</code>.

        <p>Two numeric values are known not to be equal when their domains are disjoint. 
Furthermore, two real values are known not to be equal when their ranges are
disjoint, i.e. the upper bound of one is greater than the lower bound of the
other.

        <p>When a new variable is created, the values of <code>x1</code>, <code>x2</code>, and <code>v</code> are mutually
constrained via noticers so that <code>v</code> is equal to <code>t</code> if and only if <code>x1</code> is known to
be equal to <code>x2</code>, and <code>v</code> is equal to <code>nil</code> if and only if <code>x1</code> is known not to be
equal to <code>x2</code>.

          <ul>
<li>If it later becomes known that <code>x1</code> is equal to <code>x2</code> noticers attached to <code>x1</code> and
  <code>x2</code> restrict <code>v</code> to equal <code>t</code>. Likewise if it later becomes known that <code>x1</code> is not
  equal to <code>x2</code> noticers attached to <code>x1</code> and <code>x2</code> restrict <code>v</code> to equal <code>nil</code>.

          <li>If <code>v</code> ever becomes known to equal <code>t</code> then a noticer attached to <code>v</code> restricts <code>x1</code>
  to be equal to <code>x2</code>. Likewise if <code>v</code> ever becomes known to equal <code>nil</code> then a
  noticer attached to <code>v</code> restricts <code>x1</code> not to be equal to <code>x2</code>.

          <li>If <code>x1</code> is known to be real then the noticer attached to <code>x2</code> continually
  restrict the upper bound of <code>x1</code> to be no higher than the upper bound of <code>x2</code>
  and the lower bound of <code>x1</code> to be no lower than the lower bound of <code>x2</code>. 
  Likewise for bounds of <code>x1</code> if <code>x2</code> is known to be real.

        </ul>
        Restricting two values x1 and x2 to be equal is performed by attaching
noticers to x1 and x2. These noticers continually restrict the domains of x1
and x2 to be equivalent sets (using the Common Lisp function <code>=</code> as a test
function) as their domains are restricted.

        <p>Restricting two values <code>x1</code> and <code>x2</code> to not be equal is also performed by
attaching noticers to <code>x1</code> and <code>x2</code>. These noticers however do not restrict the
domains or ranges of <code>x1</code> or <code>x2</code>. They simply monitor their continually
restrictions and fail when any assertion causes <code>x1</code> to be known to be equal to
<code>x2</code>. 
</p></blockquote></div>

   <p><a name="Function-integerpv"></a>

<div class="defun">
&mdash; Function: <b>integerpv</b><var> x<a name="index-integerpv-47"></a></var><br>
<blockquote><p><a name="index-integerpv-48"></a>Returns <code>t</code> if <code>x</code> is known to be integer valued, and <code>nil</code> if <code>x</code> is known be
non-integer value.

        <p>If it is not known whether or not <code>x</code> is integer valued when <code>integerpv</code> is called
then <code>integerpv</code> creates and returns a new boolean variable <code>v</code>.

        <p>The values of <code>x</code> and <code>v</code> are mutually constrained via noticers so that <code>v</code> is equal
to <code>t</code> if and only if <code>x</code> is known to be integer valued, and <code>v</code> is equal to <code>nil</code> if
and only if <code>x</code> is known to be non-integer valued.

        <p>If <code>x</code> later becomes known to be integer valued, a noticer attached to <code>x</code>
restricts <code>v</code> to equal <code>t</code>. Likewise, if <code>x</code> later becomes known to be non-integer
valued, a noticer attached to <code>x</code> restricts <code>v</code> to equal <code>nil</code>.

        <p>Furthermore, if <code>v</code> ever becomes known to equal <code>t</code> then a noticer attached to <code>v</code>
restricts <code>x</code> to be integer valued. Likewise, if <code>v</code> ever becomes known to equal
<code>nil</code> then a noticer attached to <code>v</code> restricts <code>x</code> to be non-integer valued. 
</p></blockquote></div>

   <p><a name="Function-_003cv"></a>

<div class="defun">
&mdash; Function: <b>&lt;v</b><var> x &amp;rest xs<a name="index-g_t_003cv-49"></a></var><br>
<blockquote><p><a name="index-g_t_003cv-50"></a>Returns a boolean value which is constrained to be <code>t</code> if each argument Xi is
less than the following argument Xi+1 and constrained to be <code>nil</code> if some
argument Xi is greater than or equal to the following argument Xi+1.

        <p>This function takes one or more arguments. All of the arguments are restricted
to be real.

        <p>Returns <code>t</code> when called with one argument. A call such as <code>(&lt;v x1 x2 ... xn)</code>
with more than two arguments behaves like a conjunction of two argument calls:

     <pre class="lisp">          
            (ANDV (&lt;V X1 X2) ... (&lt;V Xi Xi+1 ) ... (&lt;V XNn-1 Xn))
     </pre>
        <p>When called with two arguments, returns <code>t</code> if <code>x1</code> is known to be less than <code>x2</code> at
the time of call, <code>nil</code> if <code>x1</code> is known to be greater than or equal to <code>x2</code> at the
time of call, and otherwise a new boolean variable <code>v</code>.

        <p>A real value <code>x1</code> is known to be less than a real value <code>x2</code> if <code>x1</code> has an upper
bound, <code>x2</code> has a lower bound and the upper bound of <code>x1</code> is less than the lower
bound of <code>x2</code>.

        <p>A real value <code>x1</code> is known to be greater than or equal to a real value <code>x2</code> if <code>x1</code>
has a lower bound, <code>x2</code> has an upper bound and the lower bound of <code>x1</code> is greater
than or equal to the upper bound of <code>x2</code>.

        <p>When a new variable is created, the values of <code>x1</code>, <code>x2</code> and v are mutually
constrained via noticers so that <code>v</code> is equal to <code>t</code> if and only if <code>x1</code> is known to
be less than <code>x2</code> and <code>v</code> is equal to <code>nil</code> if and only if <code>x1</code> is known to be greater
than or equal to <code>x2</code>.

          <ul>
<li>If it later becomes known that <code>x1</code> is less than <code>x2</code>, noticers attached to <code>x1</code>
  and <code>x2</code> restrict <code>v</code> to equal <code>t</code>. Likewise, if it later becomes known that <code>x1</code> is
  greater than or equal to <code>x2</code>, noticers attached to <code>x1</code> and <code>x2</code> restrict <code>v</code> to
  equal <code>nil</code>.

          <li>If <code>v</code> ever becomes known to equal <code>t</code> then a noticer attached to <code>v</code> restricts <code>x1</code>
  to be less than <code>x2</code>. Likewise, if <code>v</code> ever becomes known to equal <code>nil</code> then a
  noticer attached to <code>v</code> restricts <code>x1</code> to be greater than or equal to <code>x2</code>.

        </ul>
        Restricting a real value <code>x1</code> to be less than a real value <code>x2</code> is performed by
attaching noticers to <code>x1</code> and <code>x2</code>. The noticer attached to <code>x1</code> continually
restricts the lower bound of <code>x2</code> to be no lower than the upper bound of <code>x1</code> if
<code>x1</code> has an upper bound. The noticer attached to <code>x2</code> continually restricts the
upper bound of <code>x1</code> to be no higher than the lower bound of <code>x2</code> if <code>x2</code> has a lower
bound. Since these restrictions only guarantee that <code>x1</code> be less than or equal
to <code>x2</code>, the constraint that <code>x1</code> be strictly less than <code>x2</code> is enforced by having
the noticers fail when both <code>x1</code> and <code>x2</code> become known to be equal.

        <p>Restricting a real value <code>x1</code> to be greater than or equal to a real value <code>x2</code> is
performed by an analogous set of noticers without this last equality check. 
</p></blockquote></div>

   <p><a name="Function-_002f_003dv"></a>

<div class="defun">
&mdash; Function: <b>/=v</b><var> x &amp;rest xs<a name="index-g_t_002f_003dv-51"></a></var><br>
<blockquote><p><a name="index-g_t_002f_003dv-52"></a>Returns a boolean value which is constrained to be <code>t</code> if no two arguments
are numerically equal, and constrained to be <code>nil</code> if any two or more arguments
are numerically equal.

        <p>This function takes one or more arguments. All of the arguments are restricted
to be numeric.

        <p>Returns <code>t</code> when called with one argument. A call such as <code>(/=v x1 x2 ... xn)</code>
with more than two arguments behaves like a conjunction of two argument calls:

     <pre class="lisp">          
            (ANDV (/=V X1 X2) ... (/=V X1 Xn)
                  (/=V X2 X3) ... (/=V X2 Xn)
                  ...
                  (/=V Xi Xi+1 ... (/=V Xi Xn)
                  ...
                  (/=V Xn-1 xn))
     </pre>
        <p>When called with two arguments, returns <code>t</code> if <code>x1</code> is known not to be equal to <code>x2</code>
at the time of call, <code>nil</code> if <code>x1</code> is known to be equal to <code>x2</code> at the time of
call, and otherwise a new boolean variable <code>v</code>.

        <p>Two numeric values are known not to be equal when their domains are disjoint.

        <p>Two real values are known not to be equal when their ranges are disjoint, i.e. 
the upper bound of one is greater than the lower bound of the other.

        <p>Two numeric values are known to be equal only when they are both bound and
equal according to the Common Lisp function <code>=</code>.

        <p>When a new variable is created, the values of <code>x1</code>, <code>x2</code> and <code>v</code> are mutually
constrained via noticers so that <code>v</code> is equal to <code>t</code> if and only if <code>x1</code> is known
not to be equal to <code>x2</code> and <code>v</code> is equal to <code>nil</code> if and only if <code>x1</code> is known to be
equal to <code>x2</code>.

          <ul>
<li>If it later becomes known that <code>x1</code> is not equal to <code>x2</code>, noticers attached to
  <code>x1</code> and <code>x2</code> restrict <code>v</code> to equal <code>t</code>. Likewise, if it later becomes known that <code>x1</code>
  is equal to <code>x2</code>, noticers attached to <code>x1</code> and <code>x2</code> restrict <code>v</code> to equal <code>nil</code>.

          <li>If <code>v</code> ever becomes known to equal <code>t</code> then a noticer attached to <code>v</code> restricts <code>x1</code>
  to not be equal to <code>x2</code>. Likewise, if <code>v</code> ever becomes known to equal <code>nil</code> then a
  noticer attached to <code>v</code> restricts <code>x1</code> to be equal to <code>x2</code>.

        </ul>
        Restricting two values <code>x1</code> and <code>x2</code> to be equal is performed by attaching
noticers to <code>x1</code> and <code>x2</code>. These noticers continually restrict the domains of <code>x1</code>
and <code>x2</code> to be equivalent sets (using the Common Lisp function <code>=</code> as a test
function) as their domains are restricted. Furthermore, if <code>x1</code> is known to be
real then the noticer attached to <code>x2</code> continually restrict the upper bound of
<code>x1</code> to be no higher than the upper bound of <code>x2</code> and the lower bound of <code>x1</code> to be
no lower than the lower bound of <code>x2</code>. The noticer of <code>x2</code> performs a symmetric
restriction on the bounds of <code>x1</code> if it is known to be real.

        <p>Restricting two values <code>x1</code> and <code>x2</code> to not be equal is also performed by
attaching noticers to <code>x1</code> and <code>x2</code>. These noticers however, do not restrict the
domains or ranges of <code>x1</code> or <code>x2</code>. They simply monitor their continually
restrictions and fail when any assertion causes <code>x1</code> to be known to be equal to
<code>x2</code>. 
</p></blockquote></div>

   <p><a name="Function-make_002dvariable"></a>

<div class="defun">
&mdash; Function: <b>make-variable</b><var> &amp;optional name<a name="index-make_002dvariable-53"></a></var><br>
<blockquote><p><a name="index-make_002dvariable-54"></a>Creates and returns a new variable. Variables are assigned a name
which is only used to identify the variable when it is printed. If the
parameter <code>name</code> is given then it is assigned as the name of the
variable. Otherwise, a unique name is assigned. The parameter <code>name</code> can
be any Lisp object. 
</p></blockquote></div>

   <p><a name="Function-memberv"></a>

<div class="defun">
&mdash; Function: <b>memberv</b><var> x sequence<a name="index-memberv-55"></a></var><br>
<blockquote><p><a name="index-memberv-56"></a>Returns <code>t</code> if <code>x</code> is known to be a member of <code>sequence</code> (using the Common Lisp
function <code>eql</code> as a test function), <code>nil</code> if <code>x</code> is known not to be a member of
<code>sequence</code>, and otherwise returns a new boolean variable <code>v</code>.

        <p>When a new variable is created, the values of <code>x</code> and <code>v</code> are mutually constrained
via noticers so that <code>v</code> is equal to <code>t</code> if and only if <code>x</code> is known to be a member
of <code>sequence</code> and <code>v</code> is equal to <code>nil</code> if and only if <code>x</code> is known not to be a member
of <code>sequence</code>.

          <ul>
<li>If <code>x</code> later becomes known to be a member of <code>sequence</code>, a noticer attached to <code>x</code>
  restricts v to equal <code>t</code>. Likewise, if <code>x</code> later becomes known not to be a
  member of <code>sequence</code>, a noticer attached to <code>x</code> restricts <code>v</code> to equal <code>nil</code>.

          <li>If <code>v</code> ever becomes known to equal <code>t</code> then a noticer attached to <code>v</code> restricts <code>x</code>
  to be a member of <code>sequence</code>. Likewise, if <code>v</code> ever becomes known to equal <code>nil</code>
  then a noticer attached to <code>v</code> restricts <code>x</code> not to be a member of <code>sequence</code>.

        </ul>
        The current implementation imposes two constraints on the parameter <code>sequence</code>. 
First, <code>sequence</code> must be bound when <code>memberv</code> is called. Second, <code>sequence</code> must
not contain any unbound variables when <code>memberv</code> is called.

        <p>The value of parameter <code>sequence</code> must be a sequence, i.e. either a list or a
vector. 
</p></blockquote></div>

   <p><a name="Function-numberpv"></a>

<div class="defun">
&mdash; Function: <b>numberpv</b><var> x<a name="index-numberpv-57"></a></var><br>
<blockquote><p><a name="index-numberpv-58"></a>Returns <code>t</code> if <code>x</code> is known to be numeric, <code>nil</code> if <code>x</code> is known to be
non-numeric, and otherwise returns a new boolean variable <code>v</code>.

        <p>The values of <code>x</code> and <code>v</code> are mutually constrained via noticers so that <code>v</code> is equal
to <code>t</code> if and only if <code>x</code> is known to be numeric and <code>v</code> is equal to <code>nil</code> if and only
if <code>x</code> is known to be non-numeric.

          <ul>
<li>If <code>x</code> later becomes known to be numeric, a noticer attached to <code>x</code> restricts <code>v</code>
  to equal <code>t</code>. Likewise, if <code>x</code> later becomes known to be non-numeric, a noticer
  attached to <code>x</code> restricts <code>v</code> to equal <code>nil</code>.

          <li>If <code>v</code> ever becomes known
  to equal <code>t</code> then a noticer attached to <code>v</code> restricts <code>x</code> to be numeric. Likewise,
  if <code>v</code> ever becomes known to equal <code>nil</code> then a noticer attached to <code>v</code> restricts <code>x</code>
  to be non-numeric. 
</ul>
        </p></blockquote></div>

   <p><a name="Function-realpv"></a>

<div class="defun">
&mdash; Function: <b>realpv</b><var> x<a name="index-realpv-59"></a></var><br>
<blockquote><p><a name="index-realpv-60"></a>Returns <code>t</code> if <code>x</code> is known to be real, <code>nil</code> if <code>x</code> is known to be non-real,
and otherwise returns a new boolean variable <code>v</code>.

        <p>The values of <code>x</code> and <code>v</code> are mutually constrained via noticers so that <code>v</code> is equal
to <code>t</code> if and only if <code>x</code> is known to be real and <code>v</code> is equal to <code>nil</code> if and only if
<code>x</code> is known to be non-real.

          <ul>
<li>If <code>x</code> later becomes known to be real, a noticer attached to <code>x</code> restricts <code>v</code> to
  equal <code>t</code>. Likewise, if <code>x</code> later becomes known to be non-real, a noticer
  attached to <code>x</code> restricts <code>v</code> to equal <code>nil</code>.

          <li>If <code>v</code> ever becomes known to equal <code>t</code> then a noticer attached to <code>v</code> restricts <code>x</code>
  to be real. Likewise, if <code>v</code> ever becomes known to equal <code>nil</code> then a noticer
  attached to <code>v</code> restricts <code>x</code> to be non-real. 
</ul>
        </p></blockquote></div>

   <p><a name="Function-a_002dbooleanv"></a>

<div class="defun">
&mdash; Function: <b>a-booleanv</b><var> &amp;optional name<a name="index-a_002dbooleanv-61"></a></var><br>
<blockquote><p><a name="index-a_002dbooleanv-62"></a>Returns a boolean variable. 
</p></blockquote></div>

   <p><a name="Function-a_002drealv"></a>

<div class="defun">
&mdash; Function: <b>a-realv</b><var> &amp;optional name<a name="index-a_002drealv-63"></a></var><br>
<blockquote><p><a name="index-a_002drealv-64"></a>Returns a real variable. 
</p></blockquote></div>

   <p><a name="Function-a_002dreal_002dabovev"></a>

<div class="defun">
&mdash; Function: <b>a-real-abovev</b><var> low &amp;optional name<a name="index-a_002dreal_002dabovev-65"></a></var><br>
<blockquote><p><a name="index-a_002dreal_002dabovev-66"></a>Returns a real variable whose value is constrained to be greater than or equal to <code>low</code>. 
</p></blockquote></div>

   <p><a name="Function-a_002dreal_002dbelowv"></a>

<div class="defun">
&mdash; Function: <b>a-real-belowv</b><var> high &amp;optional name<a name="index-a_002dreal_002dbelowv-67"></a></var><br>
<blockquote><p><a name="index-a_002dreal_002dbelowv-68"></a>Returns a real variable whose value is constrained to be less than or equal to <code>high</code>. 
</p></blockquote></div>

   <p><a name="Function-a_002dreal_002dbetweenv"></a>

<div class="defun">
&mdash; Function: <b>a-real-betweenv</b><var> low high &amp;optional name<a name="index-a_002dreal_002dbetweenv-69"></a></var><br>
<blockquote><p><a name="index-a_002dreal_002dbetweenv-70"></a>Returns a real variable whose value is constrained to be greater than or
equal to low and less than or equal to high. If the resulting real variable is
bound, its value is returned instead. Fails if it is known that low is greater
than high at the time of call.

        <p>The expression <code>(a-real-betweenv low high) </code>is an abbreviation for:

     <pre class="lisp">          
           (LET ((V (MAKE-VARIABLE)))
              (ASSERT! (REALPV V))
              (ASSERT! (&gt;=V V LOW))
              (ASSERT! (&lt;=V V HIGH))
              (VALUE-OF V))
     </pre>
        </blockquote></div>

   <p><a name="Function-an_002dintegerv"></a>

<div class="defun">
&mdash; Function: <b>an-integerv</b><var> &amp;optional name<a name="index-an_002dintegerv-71"></a></var><br>
<blockquote><p><a name="index-an_002dintegerv-72"></a>Returns an integer variable. 
</p></blockquote></div>

   <p><a name="Function-an_002dinteger_002dabovev"></a>

<div class="defun">
&mdash; Function: <b>an-integer-abovev</b><var> low &amp;optional name<a name="index-an_002dinteger_002dabovev-73"></a></var><br>
<blockquote><p><a name="index-an_002dinteger_002dabovev-74"></a>Returns an integer variable whose value is constrained to be greater than
or equal to <code>low</code>. 
</p></blockquote></div>

   <p><a name="Function-an_002dinteger_002dbelowv"></a>

<div class="defun">
&mdash; Function: <b>an-integer-belowv</b><var> high &amp;optional name<a name="index-an_002dinteger_002dbelowv-75"></a></var><br>
<blockquote><p><a name="index-an_002dinteger_002dbelowv-76"></a>Returns an integer variable whose value is constrained to be less than or
equal to <code>high</code>. 
</p></blockquote></div>

   <p><a name="Function-an_002dinteger_002dbetweenv"></a>

<div class="defun">
&mdash; Function: <b>an-integer-betweenv</b><var> low high &amp;optional name<a name="index-an_002dinteger_002dbetweenv-77"></a></var><br>
<blockquote><p><a name="index-an_002dinteger_002dbetweenv-78"></a>Returns an integer variable whose value is constrained to be greater than
or equal to <code>low</code> and less than or equal to <code>high</code>. If the resulting integer
variable is bound, its value is returned instead. Fails if it is known that
there is no integer between <code>low</code> and <code>high</code> at the time of call.

        <p>The expression <code>(an-integer-betweenv low high) </code>is an abbreviation for:

     <pre class="lisp">          
           (LET ((V (MAKE-VARIABLE)))
              (ASSERT! (INTEGERPV V))
              (ASSERT! (&gt;=V V LOW))
              (ASSERT! (&lt;=V V HIGH))
              (VALUE-OF v))
     </pre>
        </blockquote></div>

   <p><a name="Macro-assert_0021"></a>

<div class="defun">
&mdash; Macro: <b>assert!</b><var> x<a name="index-assert_0021-79"></a></var><br>
<blockquote><p><a name="index-assert_0021-80"></a>Restricts <code>x</code> to <code>t</code>. No meaningful result is returned. The argument <code>x</code> can be
either a variable or a non-variable.

        <p>This assertion may cause other assertions to be made due to noticers attached
to <code>x</code>.

        <p>A call to <code>assert</code>! fails if <code>x</code> is known not to equal <code>t</code> prior to the assertion or
if any of the assertions performed by the noticers result in failure.

        <p>Except for the fact that one cannot write <code>#'assert</code>!, <code>assert</code>! behaves like a
function, even though it is implemented as a macro.

        <p>The reason it is implemented as a macro is to allow a number of compile time
optimizations. Expressions like <code>(assert! (notv x))</code>, <code>(assert! (numberpv x))</code>
and <code>(assert! (notv (numberv x))) </code>are transformed into calls to functions
internal to Screamer which eliminate the need to create the boolean
variable(s) normally returned by functions like <code>notv</code> and <code>numberpv</code>. Calls to
the functions <code>numberpv</code>, <code>realpv</code>, <code>integerpv</code>, <code>memberv</code>, <code>booleanpv</code>, <code>=v</code>, <code>&lt;v</code>, <code>&lt;=v</code>,
<code>&gt;v</code>, <code>&gt;=v</code>, <code>/=v</code>, <code>notv</code>, <code>funcallv</code>, <code>applyv</code> and <code>equalv</code> which appear directly nested
in a call to <code>assert</code>!, or directly nested in a call to <code>notv</code> which is in turn
directly nested in a call to <code>assert</code>!, are similarly transformed. 
</p></blockquote></div>

   <p><a name="Macro-decide"></a>

<div class="defun">
&mdash; Macro: <b>decide</b><var> x<a name="index-decide-81"></a></var><br>
<blockquote><p><a name="index-decide-82"></a>Restricts <code>x</code> to a be boolean. After <code>x</code> is restricted a nondeterministic
choice is made. For one branch, <code>x</code> is restricted to equal <code>t</code> and <code>(decide x)</code>
returns <code>t</code> as a result. For the other branch, <code>x</code> is restricted to equal <code>nil</code> and
<code>(decide x) </code>returns <code>nil</code> as a result. The argument <code>x</code> can be either a variable
or a non-variable.

        <p>The initial restriction to boolean may cause other assertions to be made due
to noticers attached to <code>x</code>. A call to <code>decide</code> immediately fails if <code>x</code> is known
not to be boolean prior to the assertion or if any of the assertions performed
by the noticers result in failure.

        <p>Restricting <code>x</code> to be boolean attaches a noticer on <code>x</code> so that any subsequent
assertion which restricts <code>x</code> to be non-boolean will fail.

        <p>Except for implementation optimizations <code>(decide x) </code>is equivalent to:

     <pre class="lisp">          
            (EITHER (PROGN (ASSERT! X) T) (PROGN (ASSERT! (NOTV X)) NIL))
     </pre>
        <p>Except for the fact that one cannot write <code>#'decide</code>, <code>decide</code> behaves like a
function, even though it is implemented as a macro.

        <p>The reason it is implemented as a macro is to allow a number of compile time
optimizations. Expressions like <code>(decide (notv x))</code>, <code>(decide (numberpv x))</code>
and <code>(decide (notv (numberpv x))) </code>are transformed into calls to functions
internal to Screamer which eliminate the need to create the boolean
variable(s) normally returned by functions like notv and numberv. Calls to
the functions <code>numberpv</code>, <code>realpv</code>, <code>integerpv</code>, <code>memberpv</code>, <code>booleanpv</code>, <code>=v</code>, <code>&lt;v</code>, <code>&lt;=v</code>,
<code>&gt;v</code>, <code>&gt;=v</code>, <code>/=v</code>, <code>notv</code>, <code>funcallv</code>, <code>applyv</code> and <code>equalv</code> which appear directly nested
in a call to decide, or directly nested in a call to <code>notv</code> which is in turn
directly nested in a call to decide, are similarly transformed. 
</p></blockquote></div>

   <p><a name="Macro-known_003f"></a>

<div class="defun">
&mdash; Macro: <b>known?</b><var> x<a name="index-known_003f-83"></a></var><br>
<blockquote><p><a name="index-known_003f-84"></a>Restricts <code>x</code> to be a boolean. If <code>x</code> is equal to <code>t</code> after being restricted to be boolean,
returns <code>t</code>. If <code>x</code> is equal to <code>nil</code> or if the value of <code>x</code> is unknown returns <code>nil</code>. 
The argument <code>x</code> can be either a variable or a non-variable.

        <p>The initial restriction to boolean may cause other assertions to be made due
to noticers attached to <code>x</code>. A call to <code>known</code>? fails if <code>x</code> is known not to be
boolean prior to the assertion or if any of the assertions performed by the
noticers result in failure.

        <p>Restricting <code>x</code> to be boolean attaches a noticer on <code>x</code> so that any subsequent
assertion which restricts <code>x</code> to be non-boolean will fail.

        <p>Except for the fact that one cannot write <code>#'known</code>?, <code>known</code>? behaves like a
function, even though it is implemented as a macro.

        <p>The reason it is implemented as a macro is to allow a number of compile time
optimizations. Expressions like <code>(known? (notv x))</code>, <code>(known? (numberpv x))</code>
and <code>(known? (notv (numberpv x))) </code>are transformed into calls to functions
internal to Screamer which eliminate the need to create the boolean
variable(s) normally returned by functions like <code>notv</code> and <code>numberv</code>. Calls to
the functions <code>numberpv</code>, <code>realpv</code>, <code>integerpv</code>, <code>memberv</code>, <code>booleanpv</code>, <code>=v</code>, <code>&lt;v</code>, <code>&lt;=v</code>, <code>v</code>,
&gt;=v, /=v, <code>notv</code>, <code>funcallv</code>, <code>applyv</code> and <code>equalv</code> which appear directly nested in a
call to <code>known</code>?, or directly nested in a call to <code>notv</code> which is in turn directly
nested in a call to <code>known</code>?, are similarly transformed. 
</p></blockquote></div>

   <p><a name="Variable-_002amaximum_002ddiscretization_002drange_002a"></a>

<div class="defun">
&mdash; Variable: <b>*maximum-discretization-range*</b><var><a name="index-g_t_002amaximum_002ddiscretization_002drange_002a-85"></a></var><br>
<blockquote><p><a name="index-g_t_002amaximum_002ddiscretization_002drange_002a-86"></a>Discretize integer variables whose range is not greater than this number. 
Discretize all integer variables if <code>nil</code>. Must be an integer or <code>nil</code>. 
</p></blockquote></div>

   <p><a name="Variable-_002aminimum_002dshrink_002dratio_002a"></a>

<div class="defun">
&mdash; Variable: <b>*minimum-shrink-ratio*</b><var><a name="index-g_t_002aminimum_002dshrink_002dratio_002a-87"></a></var><br>
<blockquote><p><a name="index-g_t_002aminimum_002dshrink_002dratio_002a-88"></a>Ignore propagations which reduce the range of a variable by less than this
ratio. 
</p></blockquote></div>

   <p><a name="Variable-_002astrategy_002a"></a>

<div class="defun">
&mdash; Variable: <b>*strategy*</b><var><a name="index-g_t_002astrategy_002a-89"></a></var><br>
<blockquote><p><a name="index-g_t_002astrategy_002a-90"></a>Strategy to use for <code>funcallv</code> and <code>applyv</code>. Either <code>:gfc</code> for Generalized
Forward Checking, or <code>:ac</code> for Arc Consistency. Default is <code>:gfc</code>. 
</p></blockquote></div>

<h2 class="chapter"><a name="TOC15"></a>6 Miscellany</h2>

<p><a name="Function-purge"></a>

<div class="defun">
&mdash; Function: <b>purge</b><var> function-name<a name="index-purge-91"></a></var><br>
<blockquote><p><a name="index-purge-92"></a>Removes any information about <code>function-name</code> from Screamer's
who-calls database. 
</p></blockquote></div>

   <p><a name="Function-unwedge_002dscreamer"></a>

<div class="defun">
&mdash; Function: <b>unwedge-screamer</b><var><a name="index-unwedge_002dscreamer-93"></a></var><br>
<blockquote><p><a name="index-unwedge_002dscreamer-94"></a>Removes any information about all user defined functions from
Screamer's who-calls database. 
</p></blockquote></div>

   <p><a name="Variable-_002adynamic_002dextent_003f_002a"></a>

<div class="defun">
&mdash; Variable: <b>*dynamic-extent?*</b><var><a name="index-g_t_002adynamic_002dextent_003f_002a-95"></a></var><br>
<blockquote><p><a name="index-g_t_002adynamic_002dextent_003f_002a-96"></a>Set to <code>t</code> to enable the dynamic extent optimization, <code>nil</code> to
disable it. Default is platform dependent. 
</p></blockquote></div>

   <p><a name="Variable-_002ascreamer_002dversion_002a"></a>

<div class="defun">
&mdash; Variable: <b>*screamer-version*</b><var><a name="index-g_t_002ascreamer_002dversion_002a-97"></a></var><br>
<blockquote><p><a name="index-g_t_002ascreamer_002dversion_002a-98"></a>The version of Screamer which is loaded. This is currently still <code>3</code>.<code>20</code>,
while we're considering how to express versions for this copy of Screamer in
the future. 
</p></blockquote></div>

   <p><a name="Variable-_002aiscream_003f_002a"></a>

<div class="defun">
&mdash; Variable: <b>*iscream?*</b><var><a name="index-g_t_002aiscream_003f_002a-99"></a></var><br>
<blockquote><p><a name="index-g_t_002aiscream_003f_002a-100"></a><code>t</code> if Screamer is running under ILisp/GNUEmacs with iscream.el loaded. 
</p></blockquote></div>

<h2 class="chapter"><a name="TOC16"></a>7 Examples</h2>

<h3 class="section"><a name="TOC17"></a>7.1 Einstein's Riddle</h3>

<p>Solving the &ldquo;Einstein's Riddle&rdquo;, aka &ldquo;The Zebra Puzzle&rdquo; using
nondeterministic features of Screamer, ie. backtracking search.

   <p>[ <a href="http://nikodemus.github.com/screamer/examples/einstein.html">HTML</a> ]
[ <a href="http://nikodemus.github.com/screamer/examples/einstein.lisp">Source</a> ]

</body></html>

